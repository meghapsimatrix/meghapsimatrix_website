<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Megha Joshi">
<meta name="dcterms.date" content="2020-04-16">

<title>Missing Data in Propensity Score Analysis – Megha Joshi</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Missing Data in Propensity Score Analysis – Megha Joshi">
<meta property="og:description" content="">
<meta property="og:site_name" content="Megha Joshi">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Megha Joshi</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Selected Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resume/index.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meghapsimatrix"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Missing Data in Propensity Score Analysis</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">propensity score</div>
                <div class="quarto-category">missing data</div>
                <div class="quarto-category">causal inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Megha Joshi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 16, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#missing-data-methods-in-propensity-score-analysis" id="toc-missing-data-methods-in-propensity-score-analysis" class="nav-link active" data-scroll-target="#missing-data-methods-in-propensity-score-analysis">Missing Data Methods in Propensity Score Analysis</a>
  <ul class="collapse">
  <li><a href="#complete-case-analysis" id="toc-complete-case-analysis" class="nav-link" data-scroll-target="#complete-case-analysis">Complete Case Analysis</a></li>
  <li><a href="#multiple-imputation" id="toc-multiple-imputation" class="nav-link" data-scroll-target="#multiple-imputation">Multiple Imputation</a></li>
  <li><a href="#generalized-propensity-scores" id="toc-generalized-propensity-scores" class="nav-link" data-scroll-target="#generalized-propensity-scores">Generalized Propensity Scores</a></li>
  <li><a href="#other-methods" id="toc-other-methods" class="nav-link" data-scroll-target="#other-methods">Other Methods</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Theories behind propensity score analysis assume that the covariates are fully observed <span class="citation" data-cites="rosenbaum_central_1983 rosenbaum_reducing_1984">(<a href="#ref-rosenbaum_central_1983" role="doc-biblioref">Rosenbaum &amp; Rubin, 1983</a>, <a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">1984</a>)</span>. However, in practice, observational analyses require large administrative databases or surveys, which inevitably will have missingness in the covariates. The response patterns of people with missing covariates may be different than those of people with observed data <span class="citation" data-cites="mohan_graphical_2013">(<a href="#ref-mohan_graphical_2013" role="doc-biblioref">Mohan, Pearl, &amp; Tian, 2013</a>)</span>. Therefore, ways to handle missing covariate data need to be examined. The basic estimation of propensity scores using logistic regression will delete cases with missing data, which can be problematic as it can cause bias in the treatment effect estimates <span class="citation" data-cites="baraldi_introduction_2010">(<a href="#ref-baraldi_introduction_2010" role="doc-biblioref">Baraldi &amp; Enders, 2010</a>)</span>.</p>
<section id="missing-data-methods-in-propensity-score-analysis" class="level2">
<h2 class="anchored" data-anchor-id="missing-data-methods-in-propensity-score-analysis">Missing Data Methods in Propensity Score Analysis</h2>
<p>Below I explain three major methods used in the applied propensity score analysis literature when <span class="math inline">\(X\)</span> is not fully observed. I also explain three other methods to handle missing data that are not commonly used in applied literature but have been proposed theoretically. I also describe the assumptions about missing data and strong ignorability underlying each of the methods. Let <span class="math inline">\(X_{obs}\)</span> indicate the observed parts of <span class="math inline">\(X\)</span> and <span class="math inline">\(X_{mis}\)</span> indicate the missing parts of <span class="math inline">\(X\)</span>. <span class="math inline">\(D\)</span> indicates the fully observed treatment indicator and <span class="math inline">\(Y\)</span> indicates a fully observed outcome variable.</p>
<section id="complete-case-analysis" class="level3">
<h3 class="anchored" data-anchor-id="complete-case-analysis">Complete Case Analysis</h3>
<p>This approach deletes cases with missing data in any of the variables used in the analysis <span class="citation" data-cites="baraldi_introduction_2010 hill_2004">(<a href="#ref-baraldi_introduction_2010" role="doc-biblioref">Baraldi &amp; Enders, 2010</a>; <a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. The traditional propensity score estimation method of using logistic regression implements complete case analysis by default. Therefore, this method is commonly used in applied research. The data that remains after deleting cases with missing data are assumed to be a simple random sample of the full data <span class="citation" data-cites="baraldi_introduction_2010">(<a href="#ref-baraldi_introduction_2010" role="doc-biblioref">Baraldi &amp; Enders, 2010</a>)</span>. Missingness is not related to any study variables nor to the hypothetically complete values of itself. According to <span class="citation" data-cites="hill_2004">Hill (<a href="#ref-hill_2004" role="doc-biblioref">2004</a>)</span>, the assumption underlying complete case analysis is that the joint distributions of <span class="math inline">\(X_{obs}\)</span> and <span class="math inline">\(X_{mis}\)</span> are same across the two treatment conditions: <span class="math display">\[\begin{equation}
X_{obs}, X_{mis} \perp\!\!\!\perp D
\end{equation}\]</span> Therefore, an unbiased causal effect estimate can be retrieved after deleting cases with missing data. Such an assumption is very stringent and unlikely to be met in the types of data required for propensity score analyses <span class="citation" data-cites="baraldi_introduction_2010 hill_2004">(<a href="#ref-baraldi_introduction_2010" role="doc-biblioref">Baraldi &amp; Enders, 2010</a>; <a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. As mentioned above, deleting cases can also result in loss of power. Additionally, whether <span class="math inline">\(X_{mis}\)</span> is balanced between the treatment groups cannot be confirmed.</p>
</section>
<section id="multiple-imputation" class="level3">
<h3 class="anchored" data-anchor-id="multiple-imputation">Multiple Imputation</h3>
<p>Multiple imputation (MI) generates multiple sets of data with the missing values drawn from an imputation model <span class="citation" data-cites="mitra_comparison_2016 rubin_multiple_1987">(<a href="#ref-mitra_comparison_2016" role="doc-biblioref">Mitra &amp; Reiter, 2016</a>; <a href="#ref-rubin_multiple_1987" role="doc-biblioref">Rubin, 1987</a>)</span>. MI will create <span class="math inline">\(m &gt; 1\)</span> imputed datasets that contain different imputed values <span class="citation" data-cites="murray_multiple_2018 van2018flexible">(<a href="#ref-murray_multiple_2018" role="doc-biblioref">Murray, 2018</a>; <a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>. Analyses can be performed on each of the datasets and results from each dataset can be aggregated across to derive a final estimate, standard error, degrees of freedom, and test result. Thus, MI involves two stages: (1) imputation and creation of the <span class="math inline">\(m\)</span> imputed datasets, and (2) analysis and pooling of estimates across the datasets <span class="citation" data-cites="murray_multiple_2018 van2018flexible">(<a href="#ref-murray_multiple_2018" role="doc-biblioref">Murray, 2018</a>; <a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>.</p>
<p>There are two approaches for imputing multivariate missing data: (1) joint modeling, JM, and (2) fully conditional specification, FCS, also called multivariate imputation by chained equations, MICE <span class="citation" data-cites="murray_multiple_2018 van2018flexible vanB_2011">(<a href="#ref-murray_multiple_2018" role="doc-biblioref">Murray, 2018</a>; <a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>; <a href="#ref-vanB_2011" role="doc-biblioref">van Buuren &amp; Groothuis-Oudshoorn, 2011</a>)</span>. JM entails jointly modeling variables with missingness by drawing from a multivariate distribution <span class="citation" data-cites="murray_multiple_2018 van2018flexible vanB_2011">(<a href="#ref-murray_multiple_2018" role="doc-biblioref">Murray, 2018</a>; <a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>; <a href="#ref-vanB_2011" role="doc-biblioref">van Buuren &amp; Groothuis-Oudshoorn, 2011</a>)</span>. FCS entails univariate conditional imputation models of variables with missing data that iteratively condition on all other variables using Monte Carlo Markov chain methods <span class="citation" data-cites="van2018flexible vanB_2011">(<a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>; <a href="#ref-vanB_2011" role="doc-biblioref">van Buuren &amp; Groothuis-Oudshoorn, 2011</a>)</span>. JM imputes all variables simultaneously whereas FCS imputes one variable at a time <span class="citation" data-cites="van2018flexible">(<a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>. Because JM requires specification of a joint distribution for all the variables, it may not be as flexible as FCS when dealing with a large number of covariates with missing data <span class="citation" data-cites="akande2017empirical">(<a href="#ref-akande2017empirical" role="doc-biblioref">Akande, Li, &amp; Reiter, 2017</a>)</span>. However, FCS is computationally more intensive than JM <span class="citation" data-cites="van2018flexible">(<a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>. FCS also has been shown to outperform JM for categorical variables and is more robust under mis-specification of imputation model <span class="citation" data-cites="van2018flexible">(<a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>. Therefore, <span class="citation" data-cites="van2018flexible">van Buuren (<a href="#ref-van2018flexible" role="doc-biblioref">2018</a>)</span> recommended to use FCS over JM.</p>
<p>If the missingness mechanism is MAR or MCAR and if assumptions underlying the imputation model are correct, MI will yield unbiased results, as it uses the information available in <span class="math inline">\(X_{obs}\)</span> to impute missing values <span class="citation" data-cites="murray_multiple_2018">(<a href="#ref-murray_multiple_2018" role="doc-biblioref">Murray, 2018</a>)</span>. In the causal inference context, <span class="citation" data-cites="hill_2004">Hill (<a href="#ref-hill_2004" role="doc-biblioref">2004</a>)</span> argued that MI relies on the assumption of <em>latent ignorability</em>, a concept introduced by <span class="citation" data-cites="frangakis_addressing_1999">Frangakis &amp; Rubin (<a href="#ref-frangakis_addressing_1999" role="doc-biblioref">1999</a>)</span>. The assumption requires that the treatment assignment mechanism is ignorable given complete covariate data including the values that are latent or missing. These missing values are derived from MI. Below, let <span class="math inline">\(e_{MI}(X)\)</span> denote propensity scores derived after multiple imputation: <span class="math display">\[\begin{equation}
X_{obs}, X_{mis} \perp\!\!\!\perp D| e_{MI}(X)
\end{equation}\]</span> <span class="math display">\[\begin{equation}
Y(1), Y(0) \perp\!\!\!\perp D | e_{MI}(X)
\end{equation}\]</span> <span class="citation" data-cites="hill_2004">Hill (<a href="#ref-hill_2004" role="doc-biblioref">2004</a>)</span> proposed two different ways to combine propensity scores estimated in each of the <em>m</em> datasets:</p>
<section id="multiple-imputation-across-mi-across" class="level5">
<h5 class="anchored" data-anchor-id="multiple-imputation-across-mi-across">Multiple Imputation Across (MI Across)</h5>
<p>This approach involves creating <em>m</em> imputed datasets and then estimating propensity scores within each of the datasets and then averaging each unit’s <em>m</em> propensity scores across the <em>m</em> datasets <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. Stratification, matching or IPW can be implemented using these averaged propensity scores <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. Outcome models that include covariates will need to use the weights or strata derived from the averaged propensity scores and the <em>m</em> sets of covariate values. The weighted regression estimates will then need to be pooled.</p>
</section>
<section id="multiple-imputation-within-mi-within" class="level5">
<h5 class="anchored" data-anchor-id="multiple-imputation-within-mi-within">Multiple Imputation Within (MI Within)</h5>
<p>This approach involves creating <em>m</em> imputed datasets and then estimating propensity scores within each of the datasets <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. Instead of averaging the propensity scores across the datasets, this method entails conditioning on the propensity scores within the datasets and running the outcome analyses within each dataset <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. The separate regression estimates have to be pooled.</p>
</section>
</section>
<section id="generalized-propensity-scores" class="level3">
<h3 class="anchored" data-anchor-id="generalized-propensity-scores">Generalized Propensity Scores</h3>
<p><span class="citation" data-cites="rosenbaum_reducing_1984">Rosenbaum &amp; Rubin (<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">1984</a>)</span> proposed the use of generalized propensity scores (GPS) as a way to address missing covariate data. The GPS represents the probability of treatment given observed covariates and missingness indicators <span class="citation" data-cites="rosenbaum_reducing_1984">(<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">Rosenbaum &amp; Rubin, 1984</a>)</span>: <span class="math display">\[\begin{equation}
e^*(X) = P(D = 1|X_{obs}, R)
\end{equation}\]</span> Conditioning on <span class="math inline">\(e^*(X)\)</span> will balance the treatment groups in terms of the observed covariates and missingness patterns <span class="citation" data-cites="rosenbaum_reducing_1984">(<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">Rosenbaum &amp; Rubin, 1984</a>)</span>. The observed part of <span class="math inline">\(X\)</span> and the missingness pattern indicators, <span class="math inline">\(R\)</span>, will be independent of treatment assignment given the GPS <span class="citation" data-cites="rosenbaum_reducing_1984">(<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">Rosenbaum &amp; Rubin, 1984</a>)</span>: <span class="math display">\[\begin{equation}
X_{obs}, R \perp\!\!\!\perp D| e^*(X)
\end{equation}\]</span> However, conditioning on GPS will not balance the groups in terms of the unobserved values of <span class="math inline">\(X\)</span> <span class="citation" data-cites="rosenbaum_reducing_1984">(<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">Rosenbaum &amp; Rubin, 1984</a>)</span>: <span class="math display">\[\begin{equation}
X_{mis} \not\!\perp\!\!\!\perp D| e^*(X)
\end{equation}\]</span> Although this technique of treating missing data is not generally recommended for other types of missing data analyses, it has been recommended for use in propensity score analysis literature <span class="citation" data-cites="rosenbaum_reducing_1984 stuart_matching_2010">(<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">Rosenbaum &amp; Rubin, 1984</a>; <a href="#ref-stuart_matching_2010" role="doc-biblioref">Stuart, 2010</a>)</span>. In the context of propensity score analysis, this approach does not assume latent ignorability of treatment assignment because legitimate values for missing data are never derived. The assumption underlying this method is that balancing the treatment and control groups on <span class="math inline">\(X_{obs}\)</span> and <span class="math inline">\(R\)</span> is a sufficient condition to satisfy ignorability. With the GPS, the treatment and control groups are possibly not going to be balanced in terms of <span class="math inline">\(X_{mis}\)</span>.</p>
<p>For large studies with few missing data patterns, <span class="citation" data-cites="rosenbaum_reducing_1984">Rosenbaum &amp; Rubin (<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">1984</a>)</span> suggested estimating separate logit models for each missingness pattern. In practice, it is common to encounter many patterns of missing data. For these scenarios, <span class="citation" data-cites="rosenbaum_reducing_1984">Rosenbaum &amp; Rubin (<a href="#ref-rosenbaum_reducing_1984" role="doc-biblioref">1984</a>)</span> suggested creating an additional category indicating missingness for categorical variables. For continuous variables, <span class="citation" data-cites="stuart_matching_2010">Stuart (<a href="#ref-stuart_matching_2010" role="doc-biblioref">2010</a>)</span> recommended imputing missing data with a single arbitrary value, such as the overall mean of the covariate, and then creating a missingness indicator variable. In general missing data analysis context, <span class="citation" data-cites="van2018flexible">van Buuren (<a href="#ref-van2018flexible" role="doc-biblioref">2018</a>)</span> noted that this method of combining arbitrary (mean) imputation along with missingness indicators can underestimate the standard error of the estimate of interest.</p>
<p>The CART algorithms treat missing data natively as they split missingness as a category itself. In this manner, this approach is similar to the GPS which uses missingness pattern indicators when estimating propensity scores. The missingness categories are used to estimate propensity scores and conditioning on the propensity scores should balance the treatment and control condition in terms of the patterns. However, splitting does not actually impute the missing data so it is plausible to assume that like GPS, scores derived using the splitting method will not balance the groups in terms of the latent missing data. In addition, unlike MI, there are no imputed complete datasets saved to analyze for the outcome model. Therefore, splitting would need to be combined with some other technique for outcome modeling.</p>
</section>
<section id="other-methods" class="level3">
<h3 class="anchored" data-anchor-id="other-methods">Other Methods</h3>
<p>The following methods have been discussed theoretically in literature examining missing data methods in propensity score analysis. However, these methods are not commonly used in applied literature.</p>
<section id="complete-variables" class="level4">
<h4 class="anchored" data-anchor-id="complete-variables">Complete Variables</h4>
<p>This method removes any variable with missing data <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. By removing variables with missing data, the approach assumes that the distribution of those variables (both the observed and missing parts) are the same across the two treatment groups <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. If this assumption does not hold, then this method can result in bias in treatment effect estimates due to removal of important confounding variables <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>.</p>
</section>
<section id="dagostino-and-rubin-expectation-maximization" class="level4">
<h4 class="anchored" data-anchor-id="dagostino-and-rubin-expectation-maximization">D’Agostino and Rubin Expectation Maximization</h4>
<p>Another approach is a method introduced by <span class="citation" data-cites="dagostino_estimating_2000">D’Agostino &amp; Rubin (<a href="#ref-dagostino_estimating_2000" role="doc-biblioref">2000</a>)</span>, which estimates propensity scores using an Expectation Conditional Maximization (ECM) algorithm <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. This method, DR, works similar to GPS as it models <span class="math inline">\(X_{obs}\)</span>, <span class="math inline">\(R\)</span>, and the treatment indicator variable. However, instead of imputing <span class="math inline">\(X_{mis}\)</span>, the DR method uses ECM to estimate propensity scores in presence of missing data <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>. The assumption underlying DR is that within each missingness pattern defined by <span class="math inline">\(R\)</span>, <span class="math inline">\(X_{mis}\)</span> is independent of <span class="math inline">\(D\)</span> given the observed data, <span class="math inline">\(X_{obs}\)</span> <span class="citation" data-cites="hill_2004">(<a href="#ref-hill_2004" role="doc-biblioref">Hill, 2004</a>)</span>: <span class="math display">\[\begin{equation}
X_{mis} \perp\!\!\!\perp D| X_{obs}, R
\end{equation}\]</span> Such independence is sufficient to satisfy the ignorability assumption in presence of missing covariate data. With this method, the assumption cannot be checked, however, as DR does not actually impute the missing values. This method is not readily available in commonly used software like R.</p>
</section>
<section id="multiple-imputation-missingness-indicator-pattern-mixutre" class="level4">
<h4 class="anchored" data-anchor-id="multiple-imputation-missingness-indicator-pattern-mixutre">Multiple Imputation Missingness Indicator Pattern Mixutre</h4>
<p><span class="citation" data-cites="qu_propensity_2009">Qu &amp; Lipkovich (<a href="#ref-qu_propensity_2009" role="doc-biblioref">2009</a>)</span> extended MI by introducing the missingness indicator pattern mixture (MIMP) approach, which is the same as MI but adds <span class="math inline">\(R\)</span> in the propensity score estimation model. The rationale behind this approach is to use information given by missingness patterns to estimate treatment propensities. The method will assume latent ignorabilty. However, this approach should also balance the treatment group on <span class="math inline">\(R\)</span> as <span class="math inline">\(R\)</span> is used to estimate the propensity scores: <span class="math display">\[\begin{equation}
X_{obs}, X_{mis}, R \perp\!\!\!\perp D| e_{MIMP}(X)
\end{equation}\]</span> <span class="citation" data-cites="qu_propensity_2009">Qu &amp; Lipkovich (<a href="#ref-qu_propensity_2009" role="doc-biblioref">2009</a>)</span> argued that extending MI by adding R to the propensity score estimation accounts for non-ignorability or MNAR <span class="citation" data-cites="qu_propensity_2009 van2018flexible">(<a href="#ref-qu_propensity_2009" role="doc-biblioref">Qu &amp; Lipkovich, 2009</a>; <a href="#ref-van2018flexible" role="doc-biblioref">van Buuren, 2018</a>)</span>. This method allows missingness itself to provide information on missingness: <span class="math display">\[\begin{equation}
P(X| X_{obs}, R = 1) \neq P(X| X_{obs}, R = 0)
\end{equation}\]</span></p>
</section>
</section>
</section>
<section id="references" class="level1">




</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-akande2017empirical" class="csl-entry" role="listitem">
Akande, O., Li, F., &amp; Reiter, J. (2017). An empirical comparison of multiple imputation methods for categorical data. <em>The American Statistician</em>, <em>71</em>(2), 162–170.
</div>
<div id="ref-baraldi_introduction_2010" class="csl-entry" role="listitem">
Baraldi, A. N., &amp; Enders, C. K. (2010). An introduction to modern missing data analyses. <em>Journal of School Psychology</em>, <em>48</em>(1), 5–37. <a href="https://doi.org/10.1016/j.jsp.2009.10.001">https://doi.org/10.1016/j.jsp.2009.10.001</a>
</div>
<div id="ref-dagostino_estimating_2000" class="csl-entry" role="listitem">
D’Agostino, R. B., &amp; Rubin, D. B. (2000). Estimating and <span>Using</span> <span>Propensity</span> <span>Scores</span> with <span>Partially</span> <span>Missing</span> <span>Data</span>. <em>Journal of the American Statistical Association</em>, <em>95</em>(451), 749. <a href="https://doi.org/10.2307/2669455">https://doi.org/10.2307/2669455</a>
</div>
<div id="ref-frangakis_addressing_1999" class="csl-entry" role="listitem">
Frangakis, C., &amp; Rubin, D. B. (1999). Addressing complications of intention-to-treat analysis in the combined presence of all-or-none treatment-noncompliance and subsequent missing outcomes. <em>Biometrika</em>, <em>86</em>(2), 365–379. <a href="https://doi.org/10.1093/biomet/86.2.365">https://doi.org/10.1093/biomet/86.2.365</a>
</div>
<div id="ref-hill_2004" class="csl-entry" role="listitem">
Hill, J. (2004). <em>Reducing bias in treatment effect estimation in observational studies suffering from missing data</em>. Columbia University Institute for Social &amp; Economic Research &amp; Policy (ISERP).
</div>
<div id="ref-mitra_comparison_2016" class="csl-entry" role="listitem">
Mitra, R., &amp; Reiter, J. P. (2016). A comparison of two methods of estimating propensity scores after multiple imputation. <em>Statistical Methods in Medical Research</em>, <em>25</em>(1), 188–204. <a href="https://doi.org/10.1177/0962280212445945">https://doi.org/10.1177/0962280212445945</a>
</div>
<div id="ref-mohan_graphical_2013" class="csl-entry" role="listitem">
Mohan, K., Pearl, J., &amp; Tian, J. (2013). Graphical models for inference with missing data. In C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, &amp; K. Q. Weinberger (Eds.), <em>Advances in neural information processing system</em> (pp. 1277–1285). Red Hook, NY: Curran Associates, Inc.
</div>
<div id="ref-murray_multiple_2018" class="csl-entry" role="listitem">
Murray, J. S. (2018). Multiple <span>Imputation</span>: <span>A</span> <span>Review</span> of <span>Practical</span> and <span>Theoretical</span> <span>Findings</span>. <em>Statistical Science</em>, <em>33</em>(2), 142–159. <a href="https://doi.org/10.1214/18-STS644">https://doi.org/10.1214/18-STS644</a>
</div>
<div id="ref-qu_propensity_2009" class="csl-entry" role="listitem">
Qu, Y., &amp; Lipkovich, I. (2009). Propensity score estimation with missing values using a multiple imputation missingness pattern (<span>MIMP</span>) approach. <em>Statistics in Medicine</em>, <em>28</em>(9), 1402–1414. <a href="https://doi.org/10.1002/sim.3549">https://doi.org/10.1002/sim.3549</a>
</div>
<div id="ref-rosenbaum_central_1983" class="csl-entry" role="listitem">
Rosenbaum, P. R., &amp; Rubin, D. B. (1983). The <span>Central</span> <span>Role</span> of the <span>Propensity</span> <span>Score</span> in <span>Observational</span> <span>Studies</span> for <span>Causal</span> <span>Effects</span>. <em>Biometrika</em>, <em>70</em>(1), 41. <a href="https://doi.org/10.2307/2335942">https://doi.org/10.2307/2335942</a>
</div>
<div id="ref-rosenbaum_reducing_1984" class="csl-entry" role="listitem">
Rosenbaum, P. R., &amp; Rubin, D. B. (1984). Reducing <span>Bias</span> in <span>Observational</span> <span>Studies</span> <span>Using</span> <span>Subclassification</span> on the <span>Propensity</span> <span>Score</span>. <em>Journal of the American Statistical Association</em>, <em>79</em>(387), 516. <a href="https://doi.org/10.2307/2288398">https://doi.org/10.2307/2288398</a>
</div>
<div id="ref-rubin_multiple_1987" class="csl-entry" role="listitem">
Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>. New York: Wiley.
</div>
<div id="ref-stuart_matching_2010" class="csl-entry" role="listitem">
Stuart, E. A. (2010). Matching <span>Methods</span> for <span>Causal</span> <span>Inference</span>: <span>A</span> <span>Review</span> and a <span>Look</span> <span>Forward</span>. <em>Statistical Science</em>, <em>25</em>(1), 1–21. <a href="https://doi.org/10.1214/09-STS313">https://doi.org/10.1214/09-STS313</a>
</div>
<div id="ref-van2018flexible" class="csl-entry" role="listitem">
van Buuren, S. (2018). <em>Flexible imputation of missing data</em>. Chapman; Hall/CRC.
</div>
<div id="ref-vanB_2011" class="csl-entry" role="listitem">
van Buuren, S., &amp; Groothuis-Oudshoorn, K. (2011). <span class="nocase">mice</span>: Multivariate imputation by chained equations in r. <em>Journal of Statistical Software</em>, <em>45</em>(3), 1–67. Retrieved from <a href="http://www.jstatsoft.org/v45/i03/">http://www.jstatsoft.org/v45/i03/</a>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/fancy-zuccutto-29a372\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>